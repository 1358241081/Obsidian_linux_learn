# <font face="楷体"><center>指定分隔符拆分字符串</center></font> #

    # sh
	split() {
	   # Usage: split "string" "delimiter"
	   IFS=$'\n' read -d "" -ra arr <<< "${1//$2/$'\n'}"
	   printf '%s\n' "${arr[@]}"
	}
 



----------   

**语法说明:**

使用范例： `split　"aa--bb--cc--dd--n　n"　"--"`

> <font size=4>IFS=$'\n'</font>

- 此处是设置内部字段分隔符（IFS);
- 环境变量IFS，称为内部字段分隔符（internal field separator），定义了bash shell用作字段分隔符的一系列字符。
	默认情况下，bash shell会将下列字符当做字段分隔符：
	- 空格
	- 制表符
	- 换行符
- 这里的作用是确保换行符是IFS，防止字符串中的空格被当做分隔符。


> <font size=4>"${1//$2/$'\n'}"</font>

- 此句是在第一个参数中用`\n`换行符替换所有匹配第二个参数字段，详见[`${ } 的一些特异功能`](./删除字符串前后空格.md)
- `"aa--bb--cc--dd--n　n" `就变成了`"aa\nbb\ncc\ndd\nn　n"`（注意：空格没有被替换）

> <font size=4><<< </font>

- `<<<`被称作Here String，是[here document](https://zh.wikipedia.org/zh-hans/Here%E6%96%87%E6%A1%A3)的一种定制形式；
- 格式是：COMMAND <<<$WORD,$WORD将被扩展并且被送入COMMAND的stdin中；

> <font size=4>read　-d ""　-ra　arr</font>

此句就是将字符串根据IFS进行分割，并将分割后的字段赋值给数组`arr`


<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>
<tr></tr>

----------

## **环境变量IFS** ##


那么下面三个IFS的区别是什么呢？

- `IFS='\n'` // 将字符\和字符n作为IFS的换行符。
- `IFS=$'\n'` // 真正的使用换行符做为字段分隔符。
- `IFS='\n':;"` // 这个赋值会将反斜杠、n、冒号、分号和双引号作为字段分隔符。

<tr></tr>
<tr></tr>
<tr></tr>
----------

## **read命令** ##


- read命令用于从标准输入中读取输入单行，并将读取的单行根据IFS变量分裂成多个字段，并将分割后的字段分别赋值给指定的变量列表。
- 如果没有指定任何存储变量，则分割后的所有字段都存储在特定变量REPLY中。
- 选项说明
```
-a：将分裂后的字段依次存储到指定的数组中，存储的起始位置从数组的index=0开始。
-d：指定读取行的结束符号。默认结束符号为换行符。
-n：限制读取N个字符就自动结束读取，如果没有读满N个字符就按下回车或遇到换行符，则也会结束读取。
-N：严格要求读满N个字符才自动结束读取，即使中途按下了回车或遇到了换行符也不结束。其中换行符或回车算一个字符。
-p：给出提示符。默认不支持"\n"换行，要换行需要特殊处理，见下文示例。例如，"-p 请输入密码："
-r：禁止反斜线的转义功能。这意味着"\"会变成文本的一部分。
-s：静默模式。输入的内容不会回显在屏幕上。
-t：给出超时时间，在达到超时时间时，read退出并返回错误。也就是说不会读取任何内容，即使已经输入了一部分。
```
<tr></tr>
<tr></tr>
<tr></tr>
----------
