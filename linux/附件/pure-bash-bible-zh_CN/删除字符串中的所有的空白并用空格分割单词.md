# <font face="楷体"><center>删除字符串中的所有的空白并用空格分割单词</center></font> #

    # sh
	trim_all() {
	    # Usage: trim_all "   example   string    "
	    set -f
	    set -- $*
	    printf '%s\n' "$*"
	    set +f
	}
 



----------   

**语法说明:**

使用范例： `trim_all "　　　aaa　　bbb　　ccc　　"`
> <font size=4>set　-f </font>

- set命令使用，-f表示取消通配符（目前测试发现去掉此句也无影响，暂时不知道作者这么写的初衷是啥）；
- +f 表示恢复通配符


> <font size=4>set　- -　$*</font>

- 同样参考man　bash中Special　Parameters一节内容即可；
- `--` （double bash）其实是bash内置命令,表示选项的结束，其后的任何参数都被视为文件名和参数；
- `$　*`相当于`$1c$2c...`，其中c是IFS变量值的第一个字符，如果未设置IFS，则参数由空格分隔；
- 即，原输入参数　"　　　aaa　　bbb　　ccc　　"　在词句执行后会被解释成"aaa　bbb　ccc"


----------

## **Linux脚本中的$#、$0、$1、$@、$*、$$、$?** ##

假设我们定义了一个命令的参数为：`"　11　　22　　33"　"44　　　55"`


- 我们可以用 **$ + 一个符号** 获取不同的参数值：

<table><tr><td bgcolor=Cornsilk>
-　**$***
　以一个单字符串显示所有向脚本传递的参数（强调整体），即：`"11　22　33　44　55"`即当成一个整体输出，每一个变量参数之间以空格隔开；

-　**$@**
　传给脚本的所有参数的列表（强调独立），即：`"11"　"22"　"33"　"44"　"55"`即每一个变量参数是独立的，可以使用for循环进行迭代输出 ；

`$*` 和 `$@` 都表示传递给函数或脚本的所有参数，不被双引号(" ")包含时，都以"$1" "$2" … "$n" 的形式输出所有参数。 
但是当它们被双引号(" ")包含时，"$*" 会将所有的参数作为一个整体，以"$1 $2 … $n"的形式输出所有参数；"$@" 会将各个参数分开，以"$1" "$2" … "$n" 的形式输出所有参数。 


-　**$#**
　添加到Shell的参数个数，此处是2个（因为双引号内被认为是一个参数)

-　**$$**
　脚本运行的当前进程ID号

-　**$?**
　显示最后命令的退出状态，0表示没有错误，其他表示有错误

-　**$!**
　Shell最后运行的后台Process的PID

-　**$0**
　脚本本身的名字

-　**$1($2,$3…)**
　传递给该shell脚本的第N个参数

</td></tr></table>
