## 内核
### 实现策略
当前，在操作系统实现方面，有以下两种主要的范型。
**微内核**：这种范型中，只有最基本的功能直接由中央内核（即微内核）实现。所有其他的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与中心内核通信。例如，独立进程可能负责实现各种文件系统、内存管理等。（当然，与系统本身的通信需要用到最基本的内存管理功能，这是由微内核实现的。但系统调用层次上的处理则由外部的服务器进程实现。）

理论上，这是一种很完美的方法，因为系统的各个部分彼此都很清楚地划分开来，同时也迫使程序员使用“清洁的”程序设计技术。这种方法的其他好处包括：动态可扩展性和在运行时切换重要组件。但由于在各个组件之间支持复杂通信需要额外的CPU时间，所以尽管微内核在各种研究领域早已经成为活跃主题，但在实用性方面进展甚微。

**宏内核**：与微内核相反，宏内核是构建系统内核的传统方法。在这种方法中，内核的全部代码，包括所有子系统（如内存管理、文件系统、设备驱动程序）都打包到一个文件中。内核中的每个函数都可以访问内核中所有其他部分。如果编程时不小心，很可能会导致源代码中出现复杂的嵌套。因为在目前，宏内核的性能仍然强于微内核，Linux仍然是依据这种范型实现的（以前亦如此）。但其中已经引进了一个重要的革新。在系统运行中，模块可以插入到内核代码中，也可以移除，这使得可以向内核动态添加功能，弥补了宏内核的一些缺陷。模块特性依赖于内核与用户层之间设计精巧的通信方法，这使得模块的热插拔和动态装载得以实现。(dkms方式 )


内核所能执行主要任务如下：
- 进程调度：linux属于***抢占式多任务*** 操作系统。
	__抢占式__：通过一组规则控制每个进程获取cpu的使用及时间，由内核调度程序决定，并非进程本身。
	__多任务__：多个进程可同时驻留于内存，且每个进程都能获得cpu使用权。
- 内存管理：linux采用***虚拟内存管理机制*** 
	1. 进程与进程、进程与内核间彼此隔离
	2. 只需将进程部分保持在内存中，降低进程对内存的需求量，RAM中可以加载更多的进程。
- 提供文件系统：virtual file system,允许对文件执行增删改查等操作
- 创建和终止进程：为新进程提供资源，以及结束进程后释放其占用资源
- 对设备的访问：为程序访问设备提供简化版标准接口，同时**仲裁**多个进程对每一个设备的访问。
- 联网：内核以用户进程名义收发网络消息。
- 提供系统调用应用编程接口：进程可利用内核入口点（系统调用）请求内核执行任务。

>内核态和用户态：
>现代处理器架构一般允许cpu至少在两种不同状态下运行：用户态和核心态（或监管态 supervisor mode）。通过硬件指令可使cpu在两种状态间切换。
>与之对应 ，可将虚拟内存区域标记为用户空间和内核空间，在用户态运行时，cpu只能访问用户空间内存，访问内核空间内存会引发硬件异常。当cpu运行在核心态时 用户空间内存和内核空间内存都可以访问。
>执行宕机指令关闭系统，访问内存管理硬件 ，设备io操作的初始化等都是在核心态才能运行。操作系统运行与内核空间，确保用户进程既不能访问内核指令和数据结构，也无法执行不利于系统运行的操作。





